// Generated by CoffeeScript 2.3.1
(function() {
  module.exports = function(robot) {
    var Entry, InitiativeQueue, current_initiative_queue;
    Entry = class Entry {
      constructor(name, initiative) {
        this.name = name;
        this.initiative = parseInt(initiative, 10);
      }

      match(name) {
        return this.name === name;
      }

      pass() {
        return this.initiative = this.initiative - 10;
      }

      display() {
        return `\`${this.name}\` - ${this.initiative}`;
      }

      dup() {
        return new Entry(this.name, this.initiative);
      }

    };
    InitiativeQueue = class InitiativeQueue {
      constructor(hubot_brain) {
        var base, base1;
        this.store = hubot_brain;
        if ((base = this.store)['current_round'] == null) {
          base['current_round'] = [];
        }
        if ((base1 = this.store)['lineup'] == null) {
          base1['lineup'] = [];
        }
      }

      queue() {
        return this.store['current_round'];
      }

      sort(queue) {
        return queue.sort(function(a, b) {
          return b.initiative - a.initiative;
        });
      }

      set(queue_name, new_queue) {
        return this.store[queue_name] = this.sort(new_queue).map(function(entry) {
          return entry.dup();
        });
      }

      add(entry) {
        var temp_q;
        temp_q = this.queue().slice(0);
        temp_q.push(entry);
        this.set('current_round', temp_q);
        return this.set('lineup', temp_q);
      }

      remove(name) {
        remove_from_queue('current_round', name);
        return remove_from_queue('lineup', name);
      }

      remove_from_queue(queue_name, entry_name) {
        var entry_to_remove, index_for_removal;
        entry_to_remove = this.store[queue_name].filter(function(entry) {
          return entry.match(entry_name);
        });
        index_for_removal = this.store[queue_name].indexOf(entry_to_remove[0]);
        return this.store[queue_name].splice(index_for_removal, 1);
      }

      next() {
        var current_entry;
        current_entry = this.queue().shift();
        current_entry.pass();
        // If the entry still has initiative, push it back to the queue
        if (current_entry.initiative > 0) {
          this.queue().push(current_entry);
        }
        // If we don't have anything left in the queue, reset it
        if (this.queue().length < 1) {
          return this.reset_queue();
        }
      }

      reset_queue() {
        return this.set('current_round', this.store['lineup']);
      }

      show_queue() {
        var to_display;
        to_display = this.queue().map(function(entry) {
          return entry.display();
        });
        to_display[0] = `${to_display[0]} (*CURRENT PLAYER*)`;
        return `\n\n\nThe Initiative Queue is:\n${to_display.join("\n")}`;
      }

    };
    current_initiative_queue = null;
    robot.respond(/start initiative/i, function(res) {
      current_initiative_queue = new InitiativeQueue(robot.brain);
      return res.send("*** *Initiative has begun!* ***\nThe following commands are now available for use:\n\n`show me the queue` - Shows the current initiative queue\n`add <name> to initiative <number>` - Adds an entry for <name> in the initiative queue with number\n`next` - Goes to the next turn in the initiative queue\n`remove <name> from initiative` - Removes the entry <name> from the initiative queue\n`stop initiative` - Stops the initiative queue (the Queue will need to be reinstantiated with `start initiative`)");
    });
    robot.respond(/stop initiative/i, function(res) {
      current_initiative_queue = null;
      return res.send("*** *Initiative has now ended* ***\n\nUse `start initiative` to begin another round.");
    });
    robot.respond(/show me the queue/i, function(res) {
      if (current_initiative_queue) {
        return res.send(current_initiative_queue.show_queue());
      } else {
        return res.send("We are not currently in initiative");
      }
    });
    robot.respond(/add (.*) to initiative ([0-9]*)/i, function(res) {
      var char_name, entry, number;
      if (current_initiative_queue) {
        char_name = res.match[1];
        number = res.match[2];
        entry = new Entry(char_name, number);
        current_initiative_queue.add(entry);
        res.send(`${char_name} has been added to the initiative queue.`);
        return res.send(current_initiative_queue.show_queue());
      } else {
        return res.send("We are not currently in initiative");
      }
    });
    return robot.respond(/next/i, function(res) {
      current_initiative_queue.next();
      res.send("The turn has been passed");
      return res.send(current_initiative_queue.show_queue());
    });
  };

}).call(this);
